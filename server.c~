#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "executioner.h"

#include "networking.h"

void process( char * s );
void sub_server( int sd );

int main() {

  int x = 1;
  int f;
  int sd, connection;

  char buffer[MESSAGE_BUFFER_SIZE];

  sd = server_setup();
  printf("Waiting to connect... \n");

  while (x) {
    int sockfd, i, clisize;
  //   int numplayers = 0;

  //   connection = server_connect( sd );

  //   if (numplayers > 4){
  //     x = 0;
  //   }
  //   //printf("start game? (y/n)? ");
  //   //fgets(buffer, sizeof(buffer), stdin);
  //   // if (strchr(buffer, 'y')){
  //   f = fork();
  //   if ( f == 0 ) {
  //     close(sd);
  //     sub_server( connection );
  //     printf("Reached this exit\n");
  //     numplayers++;
  //   }        
  //   else {
  //     close( connection );
  //   }
  //   // }
  // }
  // return 0;
    
    sockfd = server_setup();
    i = listen(sd, 4);  
    struct sockaddr_in client;  
    clisize = sizeof(client); 

    while (1){
      newsockfd = accept(sockfd, (struct sockaddr * ), &client, &clisize);
      if (newsockfd < 0) {
        printf("ERROR on accept");
        exit(1);
      }
      pid = fork();

      if (pid < 0) {
               perror("ERROR on fork");
               exit(1);
            }
            
            if (pid == 0) {
               /* This is the client process */
               close(sockfd);
               sub_server(newsockfd);
               exit(0);
            }
            else {
               close(newsockfd);
            }
    }
}


void sub_server( int sd ) {
  Setup();
  Display();
  write(sd, _PUZZLE, sizeof(_PUZZLE));
  
  char buffer[MESSAGE_BUFFER_SIZE];
  
  while ( checkWin()){
    
    read( sd, buffer, sizeof(buffer));
    printf("[SERVER %d] received: %s\n", getpid(), buffer );
    Player_Input( buffer );
    Display();
    write( sd, buffer, sizeof(buffer));    
  }   
}
  

void process( char * s ) {
  /*
  while ( *s ) {
    *s = (*s - 'a' + 13) % 26 + 'a';
    s++;
  }
  */
  
}
